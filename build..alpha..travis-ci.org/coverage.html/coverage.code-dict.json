{"/home/travis/build/npmtest/node-npmtest-emberfire/test.js":"/* istanbul instrument in package npmtest_emberfire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-emberfire/lib.npmtest_emberfire.js":"/* istanbul instrument in package npmtest_emberfire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_emberfire = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_emberfire = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-emberfire/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-emberfire && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_emberfire */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_emberfire\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_emberfire.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_emberfire.rollup.js'] =\n            local.assetsDict['/assets.npmtest_emberfire.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_emberfire.__dirname + '/lib.npmtest_emberfire.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/index.js":"/* jshint node: true */\n'use strict';\n\nvar path = require('path');\nvar Webpack = require('broccoli-webpack');\nvar mergeTrees = require('broccoli-merge-trees');\n\nmodule.exports = {\n  name: 'emberfire',\n\n  included: function included(app) {\n    this._super.included(app);\n\n    // make sure app is correctly assigned when being used as a nested addon\n    if (app.app) {\n      app = app.app;\n    }\n    this.app = app;\n\n    this.app.import('vendor/firebase.amd.js');\n  },\n\n  treeForVendor: function(tree) {\n    var trees = [];\n\n    var firebase;\n\n    try {\n      var resolve = require('resolve');\n      firebase = resolve.sync('firebase/package.json', {\n        basedir: this.project.root\n      });\n    } catch (e) {\n      firebase = require.resolve('firebase/package.json');\n    }\n\n    trees.push(new Webpack([\n      path.dirname(firebase)\n    ], {\n      entry: './firebase-browser.js',\n      output: {\n        library: 'firebase',\n        libraryTarget: 'amd',\n        filename: 'firebase.amd.js'\n      }\n    }));\n\n    if (tree) {\n      trees.push(tree);\n    }\n\n    return mergeTrees(trees, { overwrite: true });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/gulpfile.js":"/* jshint node: true */\nvar gulp = require('gulp');\n\nvar del = require('del');\nvar $ = require('gulp-load-plugins')();\nvar browserify = require('browserify');\nvar source = require('vinyl-source-stream');\nvar buffer = require('vinyl-buffer');\nvar fs = require('fs');\n\ngulp.task('lint', function () {\n  return gulp.src('{addon,app,config,tests}/**/*.js')\n    .pipe($.jshint())\n    .pipe($.jshint.reporter('default'));\n});\n\ngulp.task('clean-dist', function (cb) {\n  del(['dist/'], cb);\n});\n\ngulp.task('test-page', ['clean-dist'], function() {\n  return gulp.src('vendor/legacy/index.html')\n    .pipe(gulp.dest('dist'));\n});\n\ngulp.task('build-legacy', ['lint', 'clean-dist'], function() {\n  var b = browserify(['vendor/legacy/emberfire.js'], {\n    debug: true\n  });\n\n  return b.bundle()\n    .pipe(source('emberfire.js'))\n    .pipe(buffer())\n    .pipe($.sourcemaps.init({ loadMaps: true }))\n      .pipe($.header(fs.readFileSync('vendor/legacy/header.js', 'utf8')))\n    .pipe($.sourcemaps.write('./'))\n    .pipe(gulp.dest('dist'));\n});\n\ngulp.task('build-legacy-minified', ['build-legacy', 'test-page'], function() {\n  return gulp.src('dist/emberfire.js')\n    .pipe($.rename('emberfire.min.js'))\n    .pipe($.uglify())\n    .on('error', function (e) {\n      throw new $.util.PluginError('gulp-uglify', e.message);\n    })\n    .pipe($.header(fs.readFileSync('vendor/legacy/header.js', 'utf8')))\n    .pipe(gulp.dest('dist'));\n});\n\ngulp.task('legacy', ['build-legacy-minified']);\n\ngulp.task('default', ['legacy']);\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/config/environment.js":"/*jshint node:true*/\n'use strict';\n\nmodule.exports = function(/* environment, appConfig */) {\n  return { };\n};\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/adapters/firebase.js":"import Ember from 'ember';\nimport DS from 'ember-data';\nimport Waitable from '../mixins/waitable';\nimport toPromise from '../utils/to-promise';\nimport assign from 'lodash/object/assign';\nimport forEach from 'lodash/collection/forEach';\nimport filter from 'lodash/collection/filter';\nimport map from 'lodash/collection/map';\nimport includes from 'lodash/collection/includes';\nimport indexOf from 'lodash/array/indexOf';\nimport find from 'lodash/collection/find';\n\nvar Promise = Ember.RSVP.Promise;\n\nvar uniq = function (arr) {\n  var ret = Ember.A();\n\n  arr.forEach(function(k) {\n    if (indexOf(ret, k) < 0) {\n      ret.push(k);\n    }\n  });\n\n  return ret;\n};\n\n\n/**\n * The Firebase adapter allows your store to communicate with the Firebase\n * realtime service. To use the adapter in your app, extend DS.FirebaseAdapter\n * and customize the endpoint to point to the Firebase URL where you want this\n * data to be stored.\n *\n * The adapter will automatically communicate with Firebase to persist your\n * records as neccessary. Importantly, the adapter will also update the store\n * in realtime when changes are made to the Firebase by other clients or\n * otherwise.\n */\nexport default DS.Adapter.extend(Waitable, {\n  firebase: Ember.inject.service(),\n  store: Ember.inject.service(),\n  defaultSerializer: '-firebase',\n\n\n  /**\n   * Endpoint paths can be customized by setting the Firebase property on the\n   * adapter:\n   *\n   * ```js\n   * DS.FirebaseAdapter.extend({\n   *   firebase: new Firebase('https://<my-firebase>.firebaseio.com/')\n   * });\n   * ```\n   *\n   * Requests for `App.Post` now target `https://<my-firebase>.firebaseio.com/posts`.\n   *\n   * @property firebase\n   * @type {Firebase}\n   * @constructor\n   */\n  init() {\n    this._super.apply(this, arguments);\n\n    var ref = this.get('firebase');\n    if (!ref) {\n      throw new Error('Please set the `firebase` property in the environment config.');\n    }\n    // If provided Firebase reference was a query (eg: limits), make it a ref.\n    this._ref = ref;\n    // Keep track of what types `.findAll()` has been called for\n    this._findAllMapForType = {};\n    // Keep a cache to check modified relationships against\n    this._recordCacheForType = {};\n    // Used to batch records into the store\n    this._queue = [];\n    // Payloads to push later\n    this._queuedPayloads = {};\n  },\n\n\n  /**\n   * Uses push() to generate chronologically ordered unique IDs.\n   *\n   * @return {String}\n   */\n  generateIdForRecord() {\n    return this._getKey(this._ref.push());\n  },\n\n\n  /**\n   * Use the Firebase DataSnapshot's key as the record id\n   *\n   * @param {Object} snapshot - A Firebase snapshot\n   * @param {Object} payload - The payload that will be pushed into the store\n   * @return {Object} payload\n   */\n  _assignIdToPayload(snapshot) {\n    var payload = snapshot.val();\n    if (payload !== null && typeof payload === 'object' && typeof payload.id === 'undefined') {\n      payload.id = this._getKey(snapshot);\n    }\n    return payload;\n  },\n\n\n  /**\n   * Called by the store to retrieve the JSON for a given type and ID. The\n   * method will return a promise which will resolve when the value is\n   * successfully fetched from Firebase.\n   *\n   * Additionally, from this point on, the object's value in the store will\n   * also be automatically updated whenever the remote value changes.\n   */\n  findRecord(store, typeClass, id) {\n    var ref = this._getCollectionRef(typeClass, id);\n\n    var log = `DS: FirebaseAdapter#findRecord ${typeClass.modelName} to ${ref.toString()}`;\n\n    return this._fetch(ref, log).then((snapshot) => {\n      var payload = this._assignIdToPayload(snapshot);\n      this._updateRecordCacheForType(typeClass, payload, store);\n      if (payload === null) {\n        var error = new Error(`no record was found at ${ref.toString()}`);\n            error.recordId = id;\n        throw error;\n      }\n\n      return payload;\n    });\n  },\n\n\n  /**\n   * Promise interface for once('value') that also handle test waiters.\n   *\n   * @param  {Firebase} ref\n   * @param  {String} log\n   * @return {Promise<DataSnapshot>}\n   * @private\n   */\n  _fetch(ref, log) {\n    this._incrementWaiters();\n    return new Promise((resolve, reject) => {\n\n      ref.once('value', (snapshot) => {\n        this._decrementWaiters();\n        Ember.run.scheduleOnce('afterRender', this, resolve, snapshot);\n\n      }, (err) => {\n        this._decrementWaiters();\n        Ember.run.scheduleOnce('afterRender', this, reject, err);\n      });\n\n    }, log);\n  },\n\n\n  recordWasPushed(store, modelName, record) {\n    if (!record.__listening) {\n      var typeClass = store.modelFor(modelName);\n      this.listenForChanges(store, typeClass, record);\n    }\n  },\n\n\n  recordWillUnload(store, record) {\n    if (record.__listening) {\n      this.stopListening(store, record.constructor, record);\n    }\n  },\n\n\n  recordWillDelete(store, record) {\n    record.eachRelationship((key, relationship) => {\n      if (relationship.kind === 'belongsTo') {\n        var parentRecord = record.get(relationship.key);\n        var inverseKey = record.inverseFor(relationship.key);\n        if (inverseKey && parentRecord.get('id')) {\n          var parentRef = this._getCollectionRef(inverseKey.type, parentRecord.get('id'));\n          this._removeHasManyRecord(store, parentRef, inverseKey.name, record.constructor, record.id);\n        }\n      }\n    });\n  },\n\n\n  listenForChanges(store, typeClass, record) {\n    // embedded records will get their changes from parent listeners\n    if (!this.isRecordEmbedded(record)) {\n      record.__listening = true;\n      var ref = this._getCollectionRef(typeClass, record.id);\n      var called = false;\n      ref.on('value', (snapshot) => {\n        if (called) {\n          Ember.run(() => {\n            this._handleChildValue(store, typeClass, snapshot);\n          });\n        }\n        called = true;\n      }, (error) => {\n        Ember.Logger.error(error);\n      });\n    }\n  },\n\n\n  stopListening(store, typeClass, record) {\n    if (record.__listening) {\n      var ref = this._getCollectionRef(typeClass, record.id);\n      ref.off('value');\n      record.__listening = false;\n    }\n  },\n\n\n  /**\n   * Called by the store to retrieve the JSON for all of the records for a\n   * given type. The method will return a promise which will resolve when the\n   * value is successfully fetched from Firebase.\n   *\n   * Additionally, from this point on, any records of this type that are added,\n   * removed or modified from Firebase will automatically be reflected in the\n   * store.\n   */\n  findAll(store, typeClass) {\n    var ref = this._getCollectionRef(typeClass);\n\n    var log = `DS: FirebaseAdapter#findAll ${typeClass.modelName} to ${ref.toString()}`;\n\n    return this._fetch(ref, log).then((snapshot) => {\n      if (!this._findAllHasEventsForType(typeClass)) {\n        this._findAllAddEventListeners(store, typeClass, ref);\n      }\n      var results = [];\n      snapshot.forEach((childSnapshot) => {\n        var payload = this._assignIdToPayload(childSnapshot);\n        this._updateRecordCacheForType(typeClass, payload, store);\n        results.push(payload);\n      });\n\n      return results;\n    });\n  },\n\n\n  query(store, typeClass, query, recordArray) {\n    var ref = this._getCollectionRef(typeClass);\n    var modelName = typeClass.modelName;\n\n    ref = this.applyQueryToRef(ref, query);\n\n    ref.on('child_added', Ember.run.bind(this, function (snapshot) {\n      var record = store.peekRecord(modelName, this._getKey(snapshot));\n\n      if (!record || !record.__listening) {\n        var payload = this._assignIdToPayload(snapshot);\n        var normalizedData = store.normalize(typeClass.modelName, payload);\n        this._updateRecordCacheForType(typeClass, payload, store);\n        record = store.push(normalizedData);\n      }\n\n      if (record) {\n        recordArray.get('content').addObject(record._internalModel);\n      }\n    }));\n\n    // `child_changed` is already handled by the record's\n    // value listener after a store.push. `child_moved` is\n    // a much less common case because it relates to priority\n\n    ref.on('child_removed', Ember.run.bind(this, function (snapshot) {\n      var record = store.peekRecord(modelName, this._getKey(snapshot));\n      if (record) {\n        recordArray.get('content').removeObject(record._internalModel);\n      }\n    }));\n\n    // clean up event handlers when the array is being destroyed\n    // so that future firebase events wont keep trying to use a\n    // destroyed store/serializer\n    recordArray.__firebaseCleanup = function () {\n      ref.off('child_added');\n      ref.off('child_removed');\n    };\n\n    var log = `DS: FirebaseAdapter#query ${modelName} with ${query}`;\n\n    return this._fetch(ref, log).then((snapshot) => {\n      if (!this._findAllHasEventsForType(typeClass)) {\n        this._findAllAddEventListeners(store, typeClass, ref);\n      }\n      var results = [];\n      snapshot.forEach((childSnapshot) => {\n        var payload = this._assignIdToPayload(childSnapshot);\n        this._updateRecordCacheForType(typeClass, payload, store);\n        results.push(payload);\n      });\n      return results;\n    });\n  },\n\n\n  applyQueryToRef(ref, query) {\n\n    if (!query.orderBy) {\n      query.orderBy = '_key';\n    }\n\n    if (query.orderBy === '_key'){\n      ref = ref.orderByKey();\n    } else if (query.orderBy === '_value') {\n      ref = ref.orderByValue();\n    } else if (query.orderBy === '_priority') {\n      ref = ref.orderByPriority();\n    } else {\n      ref = ref.orderByChild(query.orderBy);\n    }\n\n    ['startAt', 'endAt', 'equalTo', 'limitToFirst', 'limitToLast'].forEach(function (key) {\n      if (query[key] || query[key] === '' || query[key] === false) {\n        ref = ref[key](query[key]);\n      }\n    });\n\n    return ref;\n  },\n\n\n  /**\n   * Keep track of what types `.findAll()` has been called for\n   * so duplicate listeners aren't added\n   */\n  _findAllMapForType: undefined,\n\n\n  /**\n   * Determine if the current type is already listening for children events\n   */\n  _findAllHasEventsForType(typeClass) {\n    return !Ember.isNone(this._findAllMapForType[typeClass.modelName]);\n  },\n\n\n  /**\n   * After `.findAll()` is called on a modelName, continue to listen for\n   * `child_added`, `child_removed`, and `child_changed`\n   */\n  _findAllAddEventListeners(store, typeClass, ref) {\n    var modelName = typeClass.modelName;\n    this._findAllMapForType[modelName] = true;\n\n    ref.on('child_added', Ember.run.bind(this, function (snapshot) {\n      if (!store.hasRecordForId(modelName, this._getKey(snapshot))) {\n        this._handleChildValue(store, typeClass, snapshot);\n      }\n    }));\n  },\n\n\n  /**\n   * Push a new child record into the store\n   */\n  _handleChildValue(store, typeClass, snapshot) {\n    // No idea why we need this, we are already turning off the callback by\n    // calling ref.off in recordWillUnload. Something is fishy here\n    if (store.isDestroying) {\n      return;\n    }\n    var value = snapshot.val();\n    if (value === null) {\n      var id = this._getKey(snapshot);\n      var record = store.peekRecord(typeClass.modelName, id);\n      // TODO: refactor using ED\n      if (!record.get('isDeleted')) {\n        record.deleteRecord();\n      }\n    } else {\n      const payload = this._assignIdToPayload(snapshot);\n      this._pushLater(typeClass.modelName, payload.id, payload);\n    }\n  },\n\n\n  /**\n   * `createRecord` is an alias for `updateRecord` because calling \\\n   * `ref.set()` would wipe out any existing relationships\n   */\n  createRecord(store, typeClass, snapshot) {\n    return this.updateRecord(store, typeClass, snapshot).then(() => {\n      this.listenForChanges(store, typeClass, snapshot.record);\n    });\n  },\n\n\n  /**\n   * Called by the store when a record is created/updated via the `save`\n   * method on a model record instance.\n   *\n   * The `updateRecord` method serializes the record and performs an `update()`\n   * at the the Firebase location and a `.set()` at any relationship locations\n   * The method will return a promise which will be resolved when the data and\n   * any relationships have been successfully saved to Firebase.\n   *\n   * We take an optional record reference, in order for this method to be usable\n   * for saving nested records as well.\n   */\n  updateRecord(store, typeClass, snapshot) {\n    var recordRef = this._getAbsoluteRef(snapshot.record);\n    var recordCache = this._getRecordCache(typeClass, snapshot.id);\n    var pathPieces = recordRef.path.toString().split('/');\n    var lastPiece = pathPieces[pathPieces.length-1];\n    var serializedRecord = snapshot.serialize({\n      includeId: (lastPiece !== snapshot.id) // record has no firebase `key` in path\n    });\n    const serializer = store.serializerFor(typeClass.modelName);\n\n    return new Promise((resolve, reject) => {\n      var relationshipsToSave = [];\n      // first we remove all relationships data from the serialized record, we backup the\n      // removed data so that we can save it at a later stage.\n      snapshot.record.eachRelationship((key, relationship) => {\n      const relationshipKey = serializer.keyForRelationship(key);\n      const data = serializedRecord[relationshipKey];\n      const isEmbedded = this.isRelationshipEmbedded(store, typeClass.modelName, relationship);\n      const hasMany = relationship.kind === 'hasMany';\n      if (hasMany || isEmbedded) {\n          if (!Ember.isNone(data)) {\n            relationshipsToSave.push({\n              data:data,\n              relationship:relationship,\n              isEmbedded:isEmbedded,\n              hasMany:hasMany\n            });\n          }\n          delete serializedRecord[relationshipKey];\n        }\n      });\n      var reportError = (errors) => {\n        var error = new Error(`Some errors were encountered while saving ${typeClass} ${snapshot.id}`);\n        error.errors = errors;\n        reject(error);\n      };\n      this._updateRecord(recordRef, serializedRecord).then(() => {\n        // and now we construct the list of promise to save relationships.\n        var savedRelationships = relationshipsToSave.map((relationshipToSave) => {\n            const data = relationshipToSave.data;\n            const relationship = relationshipToSave.relationship;\n            if (relationshipToSave.hasMany) {\n              return this._saveHasManyRelationship(store, typeClass, relationship, data, recordRef, recordCache);\n            } else {\n              // embedded belongsTo, we need to fill in the informations.\n              if (relationshipToSave.isEmbedded) {\n                return this._saveEmbeddedBelongsToRecord(store, typeClass, relationship, data, recordRef);\n              }\n            }\n          }\n        );\n        return Ember.RSVP.allSettled(savedRelationships);\n      }).catch((e) => {\n        reportError([e]);\n      }).then((results) => {\n        var rejected = Ember.A(results).filterBy('state', 'rejected');\n        if (rejected.length !== 0) {\n          reportError(rejected.mapBy('reason').toArray());\n        } else {\n          resolve();\n        }\n      });\n    }, `DS: FirebaseAdapter#updateRecord ${typeClass} to ${recordRef.toString()}`);\n  },\n\n\n  /**\n   * Update a single record without caring for the relationships\n   * @param  {Firebase} recordRef\n   * @param  {Object} serializedRecord\n   * @return {Promise}\n   */\n  _updateRecord(recordRef, serializedRecord) {\n    this._incrementWaiters();\n    return toPromise(recordRef.update, recordRef, [serializedRecord])\n      .then((result) => {\n        this._decrementWaiters();\n        return result;\n      })\n      .catch((e) => {\n        this._decrementWaiters();\n        return Ember.RSVP.reject(e);\n      });\n  },\n\n\n  /**\n   * Call _saveHasManyRelationshipRecord on each record in the relationship\n   * and then resolve once they have all settled\n   */\n  _saveHasManyRelationship(store, typeClass, relationship, ids, recordRef, recordCache) {\n    if (!Ember.isArray(ids)) {\n      throw new Error('hasMany relationships must must be an array');\n    }\n    var idsCache = Ember.A(recordCache[relationship.key]);\n    var dirtyRecords = [];\n\n    // Added\n    var addedRecords = filter(ids, (id) => {\n      return !idsCache.includes(id);\n    });\n\n    // Dirty\n    dirtyRecords = filter(ids, (id) => {\n      var relatedModelName = relationship.type;\n      return store.hasRecordForId(relatedModelName, id) && store.peekRecord(relatedModelName, id).get('hasDirtyAttributes') === true;\n    });\n\n    dirtyRecords = map(uniq(dirtyRecords.concat(addedRecords)), (id) => {\n      return this._saveHasManyRecord(store, typeClass, relationship, recordRef, id);\n    });\n\n    // Removed\n    var removedRecords = filter(idsCache, (id) => {\n      return !includes(ids, id);\n    });\n\n    removedRecords = map(removedRecords, (id) => {\n      return this._removeHasManyRecord(store, recordRef, relationship.key, typeClass, id);\n    });\n    // Combine all the saved records\n    var savedRecords = dirtyRecords.concat(removedRecords);\n    // Wait for all the updates to finish\n    return Ember.RSVP.allSettled(savedRecords).then((savedRecords) => {\n      var rejected = Ember.A(Ember.A(savedRecords).filterBy('state', 'rejected'));\n      if (rejected.get('length') === 0) {\n        // Update the cache\n        recordCache[relationship.key] = ids;\n        return savedRecords;\n      }\n      else {\n        var error = new Error(`Some errors were encountered while saving a hasMany relationship ${relationship.parentType} -> ${relationship.type}`);\n            error.errors = Ember.A(rejected).mapBy('reason');\n        throw error;\n      }\n    });\n  },\n\n\n  /**\n   * If the relationship is `async: true`, create a child ref\n   * named with the record id and set the value to true\n\n   * If the relationship is `embedded: true`, create a child ref\n   * named with the record id and update the value to the serialized\n   * version of the record\n   */\n  _saveHasManyRecord(store, typeClass, relationship, parentRef, id) {\n    const serializer = store.serializerFor(typeClass.modelName);\n    var ref = this._getRelationshipRef(parentRef, serializer.keyForRelationship(relationship.key), id);\n    var record = store.peekRecord(relationship.type, id);\n    var isEmbedded = this.isRelationshipEmbedded(store, typeClass.modelName, relationship);\n    if (isEmbedded) {\n      return record.save();\n    }\n\n    return toPromise(ref.set, ref,  [true]);\n  },\n\n\n  /**\n   * Determine from the serializer if the relationship is embedded via the\n   * serializer's `attrs` hash.\n   *\n   * @return {Boolean}              Is the relationship embedded?\n   */\n  isRelationshipEmbedded(store, modelName, relationship) {\n    var serializer = store.serializerFor(modelName);\n    return serializer.hasDeserializeRecordsOption(relationship.key);\n  },\n\n\n  /**\n   * Determine from if the record is embedded via implicit relationships.\n   *\n   * @return {Boolean}              Is the relationship embedded?\n   */\n  isRecordEmbedded(record) {\n    if (record._internalModel) {\n      record = record._internalModel;\n    }\n\n    var found = this.getFirstEmbeddingParent(record);\n\n    return !!found;\n  },\n\n\n  /**\n   * Remove a relationship\n   */\n  _removeHasManyRecord(store, parentRef, key, typeClass, id) {\n    const relationshipKey = store.serializerFor(typeClass.modelName).keyForRelationship(key);\n    var ref = this._getRelationshipRef(parentRef, relationshipKey, id);\n    return toPromise(ref.remove, ref, [], ref.toString());\n  },\n\n\n  /**\n   * Save an embedded belongsTo record and set its internal firebase ref\n   *\n   * @return {Promise<DS.Model>}\n   */\n  _saveEmbeddedBelongsToRecord(store, typeClass, relationship, id, parentRef) {\n    var record = store.peekRecord(relationship.type, id);\n    if (record) {\n      return record.save();\n    }\n    return Ember.RSVP.Promise.reject(new Error(`Unable to find record with id ${id} from embedded relationship: ${JSON.stringify(relationship)}`));\n  },\n\n\n  /**\n   * Called by the store when a record is deleted.\n   */\n  deleteRecord(store, typeClass, snapshot) {\n    var ref = this._getAbsoluteRef(snapshot.record);\n    ref.off('value');\n    return toPromise(ref.remove, ref);\n  },\n\n\n  /**\n   * Determines a path fo a given type\n   */\n  pathForType(modelName) {\n    var camelized = Ember.String.camelize(modelName);\n    return Ember.String.pluralize(camelized);\n  },\n\n\n  /**\n   * Return a Firebase reference for a given modelName and optional ID.\n   */\n  _getCollectionRef(typeClass, id) {\n    var ref = this._ref;\n    if (typeClass) {\n      ref = ref.child(this.pathForType(typeClass.modelName));\n    }\n    if (id) {\n      ref = ref.child(id);\n    }\n    return ref;\n  },\n\n\n  /**\n   * Returns a Firebase reference for a record taking into account if the record is embedded\n   *\n   * @param  {DS.Model} record\n   * @return {Firebase}\n   */\n  _getAbsoluteRef(record) {\n    if (record._internalModel) {\n      record = record._internalModel;\n    }\n\n    var embeddingParent = this.getFirstEmbeddingParent(record);\n\n    if (embeddingParent) {\n      var { record: parent, relationship } = embeddingParent;\n      const embeddedKey = parent.store.serializerFor(parent.modelName).keyForRelationship(relationship.key);\n      var recordRef = this._getAbsoluteRef(parent).child(embeddedKey);\n\n      if (relationship.kind === 'hasMany') {\n        recordRef = recordRef.child(record.id);\n      }\n      return recordRef;\n    }\n\n    return this._getCollectionRef(record.type, record.id);\n  },\n\n\n  /**\n   * Returns the parent record and relationship where any embedding is detected\n   *\n   * @param  {DS.InternalModel} internalModel\n   * @return {Object}\n   */\n  getFirstEmbeddingParent(internalModel) {\n    var relationships = assign(\n      {},\n      internalModel._implicitRelationships,\n      internalModel._relationships.initializedRelationships\n    );\n\n    var embeddingParentRel = find(relationships, (rel) => {\n      var members = rel.members.toArray();\n      var parent = members[0];\n\n      if (!parent || !rel.inverseKey) {\n        return false;\n      }\n\n      var parentRel = parent._relationships.get(rel.inverseKey);\n      return this.isRelationshipEmbedded(this.store, parent.type.modelName, parentRel.relationshipMeta);\n    });\n\n    if (embeddingParentRel) {\n      var parent = embeddingParentRel.members.toArray()[0];\n      var parentKey = embeddingParentRel.inverseKey;\n      var parentRel = parent._relationships.get(parentKey).relationshipMeta;\n      return { record: parent, relationship: parentRel };\n    }\n  },\n\n\n  /**\n   * Return a Firebase reference based on a relationship key and record id\n   */\n  _getRelationshipRef(ref, key, id) {\n    return ref.child(key).child(id);\n  },\n\n\n  /**\n   * The amount of time (ms) before the _queue is flushed\n   */\n  _queueFlushDelay: (1000/60), // 60fps\n\n\n  /**\n   * Schedules a `_flushQueue` for later.\n   *\n   * @private\n   */\n  _flushLater() {\n    Ember.run.later(this, this._flushQueue, this._queueFlushDelay);\n  },\n\n\n  /**\n   * Flush all delayed `store.push` payloads in `this._queuedPayloads`.\n   *\n   * @private\n   */\n  _flushQueue() {\n    const store = this.get('store');\n    if (store.isDestroying) {\n      return;\n    }\n\n    forEach(this._queue, (key) => {\n      const { payload, modelName } = this._queuedPayloads[key];\n      const normalizedData = store.normalize(modelName, payload);\n      store.push(normalizedData);\n    });\n    this._queuedPayloads = {};\n    this._queue.length = 0;\n  },\n\n\n  /**\n   * Schedule a payload push for later. This will only push at most one payload\n   * per record. When trying to push to the same record multiple times, only the\n   * last push will be kept.\n   *\n   * @param {string} modelName\n   * @param {string} id\n   * @param {!Object<string, *>} payload\n   * @private\n   */\n  _pushLater(modelName, id, payload) {\n    const store = this.get('store');\n    if (!this._queueFlushDelay) {\n      const normalizedData = store.normalize(modelName, payload);\n      store.push(normalizedData);\n      return;\n    }\n\n    const key = `${modelName}-${id}`;\n    if (this._queuedPayloads[key]) {\n      // remove from original place in queue (will be added to end)\n      const oldPosition = indexOf(this._queue, key);\n      this._queue.splice(oldPosition, 1);\n    }\n    this._queuedPayloads[key] = { payload, modelName };\n    this._queue.push(key);\n\n    // if this is the first item to be queued, schedule a flush\n    if (this._queue.length === 1) {\n      this._flushLater();\n    }\n  },\n\n\n  /**\n   * A cache of hasMany relationships that can be used to\n   * diff against new relationships when a model is saved\n   */\n  _recordCacheForType: undefined,\n\n\n  /**\n   * _updateHasManyCacheForType\n   */\n  _updateRecordCacheForType(typeClass, payload, store) {\n    if (!payload) { return; }\n    var id = payload.id;\n    var cache = this._getRecordCache(typeClass, id);\n    const serializer = store.serializerFor(typeClass.modelName);\n    // Only cache relationships for now\n    typeClass.eachRelationship((key, relationship) => {\n      if (relationship.kind === 'hasMany') {\n        var ids = payload[serializer.keyForRelationship(key)];\n        cache[key] = !Ember.isNone(ids) ? Ember.A(Object.keys(ids)) : Ember.A();\n      }\n    });\n  },\n\n\n  /**\n   * Get or create the cache for a record\n   */\n  _getRecordCache(typeClass, id) {\n    var modelName = typeClass.modelName;\n    var cache = this._recordCacheForType;\n    cache[modelName] = cache[modelName] || {};\n    cache[modelName][id] = cache[modelName][id] || {};\n    return cache[modelName][id];\n  },\n\n\n  /**\n   * A utility for retrieving the key name of a Firebase ref or\n   * DataSnapshot. This is backwards-compatible with `name()`\n   * from Firebase 1.x.x and `key()` from Firebase 2.0.0+. Once\n   * support for Firebase 1.x.x is dropped in EmberFire, this\n   * helper can be removed.\n   */\n  _getKey(refOrSnapshot) {\n    var key;\n    if (typeof refOrSnapshot.key === 'function') {\n      key = refOrSnapshot.key();\n    } else if (typeof refOrSnapshot.key === 'string') {\n      key = refOrSnapshot.key;\n    } else {\n      key = refOrSnapshot.name();\n    }\n    return key;\n  },\n\n\n  /**\n   * We don't need background reloading, because firebase!\n   */\n  shouldBackgroundReloadRecord() {\n    return false;\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/initializers/emberfire.js":"import Ember from 'ember';\nimport DS from 'ember-data';\nimport firebase from 'firebase';\nimport FirebaseAdapter from '../adapters/firebase';\nimport FirebaseSerializer from '../serializers/firebase';\nimport forEach from 'lodash/collection/forEach';\n\nvar VERSION = '0.0.0';\n\nif (Ember.libraries) {\n  if (firebase.SDK_VERSION) {\n    Ember.libraries.registerCoreLibrary('Firebase', firebase.SDK_VERSION);\n  }\n\n  Ember.libraries.registerCoreLibrary('EmberFire', VERSION);\n}\n\nexport default {\n  name: 'emberfire',\n  before: 'ember-data',\n  initialize() {\n\n    // To support Ember versions below 2.1.0 as well.\n    // See http://emberjs.com/deprecations/v2.x/#toc_initializer-arity\n    let application = arguments[1] || arguments[0];\n\n    application.register('adapter:-firebase', FirebaseAdapter);\n    application.register('serializer:-firebase', FirebaseSerializer);\n\n    const providerSettings = {instantiate: false, singleton: false};\n    application.register('firebase-auth-provider:twitter',\n        firebase.auth.TwitterAuthProvider, providerSettings);\n    application.register('firebase-auth-provider:facebook',\n        firebase.auth.FacebookAuthProvider, providerSettings);\n    application.register('firebase-auth-provider:github',\n        firebase.auth.GithubAuthProvider, providerSettings);\n    application.register('firebase-auth-provider:google',\n        firebase.auth.GoogleAuthProvider, providerSettings);\n\n    // Monkeypatch the store until ED gives us a good way to listen to push events\n    if (!DS.Store.prototype._emberfirePatched) {\n      DS.Store.reopen({\n        _emberfirePatched: true,\n\n        _emberfireHandleRecordPush(records) {\n          forEach(records, (record) => {\n            var modelName = record.constructor.modelName;\n            var adapter = this.adapterFor(modelName);\n            if (adapter.recordWasPushed) {\n              adapter.recordWasPushed(this, modelName, record);\n            }\n          });\n        },\n\n        push() {\n          var result = this._super.apply(this, arguments);\n          var records = result;\n\n          if (!Ember.isArray(result)) {\n            records = [result];\n          }\n          this._emberfireHandleRecordPush(records);\n          return result;\n        },\n\n        _push() {\n          var pushed = this._super.apply(this, arguments);\n          var records;\n          if (Array.isArray(pushed)) {\n            records = pushed.map(function(internalModel) {\n              return internalModel.getRecord();\n            });\n          } else {\n            records = [pushed.getRecord()];\n          }\n          this._emberfireHandleRecordPush(records);\n          return pushed;\n        },\n\n        recordWillUnload(record) {\n          var adapter = this.adapterFor(record.constructor.modelName);\n          if (adapter.recordWillUnload) {\n            adapter.recordWillUnload(this, record);\n          }\n        },\n\n        recordWillDelete(record) {\n          var adapter = this.adapterFor(record.constructor.modelName);\n          if (adapter.recordWillDelete) {\n            adapter.recordWillDelete(this, record);\n          }\n        }\n      });\n    }\n\n    if (!DS.Model.prototype._emberfirePatched) {\n      DS.Model.reopen({\n        _emberfirePatched: true,\n\n        unloadRecord() {\n          this.store.recordWillUnload(this);\n          return this._super();\n        },\n\n        deleteRecord() {\n          this.store.recordWillDelete(this);\n          this._super();\n        },\n\n        ref() {\n          var adapter = this.store.adapterFor(this.constructor.modelName);\n          if (adapter._getAbsoluteRef) {\n            return adapter._getAbsoluteRef(this);\n          }\n        }\n      });\n    }\n\n    if (!DS.AdapterPopulatedRecordArray.prototype._emberfirePatched) {\n      DS.AdapterPopulatedRecordArray.reopen({\n        _emberfirePatched: true,\n\n        willDestroy() {\n          if (this.__firebaseCleanup) {\n            this.__firebaseCleanup();\n          }\n          return this._super();\n        }\n      });\n    }\n\n    DS.FirebaseAdapter = FirebaseAdapter;\n    DS.FirebaseSerializer = FirebaseSerializer;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/mixins/waitable.js":"import Ember from 'ember';\n\nexport default Ember.Mixin.create({\n\n  init() {\n    this._super.apply(this, arguments);\n    // unresolved requests, used in testing\n    this._reasons = 0;\n\n    if (Ember.testing) {\n      this._registerWaiter();\n    }\n  },\n\n\n  _incrementWaiters() {\n    this._reasons++;\n  },\n\n\n  _decrementWaiters() {\n    this._reasons--;\n  },\n\n\n  /**\n   * The waiter calls this to determine if testing should wait. Override in\n   * the implementing class if needed.\n   *\n   * @return {Boolean}\n   * @private\n   */\n  _shouldWait() {\n    return this._reasons === 0;\n  },\n\n\n  /**\n   * Wire up a waiter for this instance.\n   *\n   * @private\n   */\n  _registerWaiter: function() {\n    this._waiter = () => {\n      return this._shouldWait();\n    };\n    Ember.Test.registerWaiter(this._waiter);\n  },\n\n});\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/serializers/firebase.js":"import Ember from 'ember';\nimport DS from 'ember-data';\nimport assign from 'lodash/object/assign';\nimport firebase from 'firebase';\n\n/**\n * The Firebase serializer helps normalize relationships and can be extended on\n * a per model basis.\n */\nexport default DS.JSONSerializer.extend(DS.EmbeddedRecordsMixin, {\n  isNewSerializerAPI: true,\n\n  /**\n   * Firebase have a special value for a date 'firebase.database.ServerValue.TIMESTAMP'\n   * that tells it to insert server time. We need to make sure the value is not scrapped\n   * by the data attribute transforms.\n   *\n   * @override\n   */\n  serializeAttribute(snapshot, json, key, attribute) {\n    var value = snapshot.attr(key);\n    this._super(snapshot, json, key, attribute);\n    if (this._canSerialize(key)) {\n      if (value === firebase.database.ServerValue.TIMESTAMP) {\n\n        var payloadKey = this._getMappedKey(key, snapshot.type);\n\n        if (payloadKey === key && this.keyForAttribute) {\n          payloadKey = this.keyForAttribute(key, 'serialize');\n        }\n        // do not transform\n        json[payloadKey] = value;\n      }\n    }\n  },\n\n\n  /**\n   * Firebase does not send null values, it omits the key altogether. This nullifies omitted\n   * properties so that property deletions sync correctly.\n   *\n   * @override\n   */\n  extractAttributes(modelClass, resourceHash) {\n    var attributes = this._super(modelClass, resourceHash);\n\n    // nullify omitted attributes\n    modelClass.eachAttribute((key) => {\n      if (!attributes.hasOwnProperty(key)) {\n        attributes[key] = null;\n      }\n    });\n\n    return attributes;\n  },\n\n\n  /**\n   * @override\n   */\n  extractRelationships(modelClass, payload) {\n    this.normalizeRelationships(modelClass, payload);\n    return this._super(modelClass, payload);\n  },\n\n\n  /**\n   * Normalizes `hasMany` relationship structure before passing\n   * to `JSONSerializer.extractRelationships`\n   *\n   * before:\n   *\n   * ```js\n   * {\n   *   comments: {\n   *     abc: true,\n   *     def: true,\n   *   }\n   * }\n   * ```\n   *\n   * after:\n   *\n   * ```js\n   * {\n   *   comments: [ 'abc', 'def' ]\n   * }\n   * ```\n   *\n   * Or for embedded objects:\n   *\n   * ```js\n   * {\n   *   comments: {\n   *     'abc': { body: 'a' },\n   *     'def': { body: 'd' )\n   *   }\n   * }\n   * ```\n   *\n   * these should become:\n   *\n   * ```js\n   * {\n   *   comments: [\n   *     {\n   *       id: 'abc',\n   *       body: 'a'\n   *     },\n   *     {\n   *       id: 'def',\n   *       body: 'd'\n   *     }\n   *   ]\n   * }\n   * ```\n   */\n  normalizeRelationships(modelClass, payload) {\n    modelClass.eachRelationship((key, meta) => {\n      let relationshipKey = this.keyForRelationship(key, meta.kind, 'deserialize');\n\n      if (meta.kind === 'hasMany') {\n        if (payload.hasOwnProperty(relationshipKey)) {\n          let relationshipPayload = payload[relationshipKey];\n          // embedded\n          if (this.hasDeserializeRecordsOption(key)) {\n            if (typeof relationshipPayload === 'object' && !Ember.isArray(relationshipPayload)) {\n              relationshipPayload = Object.keys(relationshipPayload).map((id) => {\n                return assign({ id: id }, relationshipPayload[id]);\n              });\n            } else if (Ember.isArray(relationshipPayload)) {\n              relationshipPayload = this._addNumericIdsToEmbeddedArray(relationshipPayload);\n            } else {\n              throw new Error(`${modelClass.toString()} relationship ${meta.kind}('${meta.type}') must contain embedded records with an \\`id\\`. Example: { \"${key}\": { \"${meta.type}_1\": { \"id\": \"${meta.type}_1\" } } } instead got: ${JSON.stringify(payload[key])}`);\n            }\n          }\n\n          // normalized\n          else {\n            if (typeof relationshipPayload === 'object' && !Ember.isArray(relationshipPayload)) {\n              relationshipPayload = Object.keys(relationshipPayload);\n            } else if (Ember.isArray(relationshipPayload)) {\n              relationshipPayload = this._convertBooleanArrayToIds(relationshipPayload);\n            } else {\n              throw new Error(`${modelClass.toString()} relationship ${meta.kind}('${meta.type}') must be a key/value map. Example: { \"${key}\": { \"${meta.type}_1\": true } } instead got: ${JSON.stringify(payload[key])}`);\n            }\n          }\n\n          payload[relationshipKey] = relationshipPayload;\n        }\n\n        // hasMany property is not present\n        // server will not send a property which has no content\n        // (i.e. it will never send `comments: null`) so we need to\n        // force the empty relationship\n        else {\n          payload[relationshipKey] = [];\n        }\n      }\n\n      if (meta.kind === 'belongsTo') {\n        if (!payload.hasOwnProperty(relationshipKey)) {\n          // server wont send property if it was made null elsewhere\n          payload[relationshipKey] = null;\n        }\n      }\n    });\n  },\n\n\n  /**\n   * Coerce arrays back into relationship arrays. When numeric ids are used\n   * the firebase server will send back arrays instead of object hashes in\n   * certain situations.\n   *\n   * See the conditions and reasoning here:\n   * https://www.firebase.com/docs/web/guide/understanding-data.html#section-arrays-in-firebase\n   *\n   * Stored in Firebase:\n   *\n   * ```json\n   * {\n   *   \"0\": true,\n   *   \"1\": true,\n   *   \"3\": true\n   * }\n   * ```\n   *\n   * Given back by the JS client:\n   *\n   * ```js\n   * [true, true, null, true]\n   * ```\n   *\n   * What we need:\n   *\n   * ```js\n   * [ \"0\", \"1\", \"3\" ]\n   * ```\n   *\n   * @param {Array} arr   Input array\n   * @return {Array}      Fixed array\n   * @private\n   */\n  _convertBooleanArrayToIds(arr) {\n    var result = [];\n    for (var i = 0; i <  arr.length; i++) {\n      if (arr[i] === true) {\n        result.push('' + i);\n      }\n      else if (typeof arr[i] === 'string') {\n        throw new Error(`hasMany relationship contains invalid data, should be in the form: { comment_1: true, comment_2: true } but was ${JSON.stringify(arr)}`);\n      }\n    }\n    return result;\n  },\n\n\n  /**\n   * Fix embedded array ids.\n   *\n   * Objects are stored in Firebase with their id in the key only:\n   *\n   * ```json\n   * {\n   *   \"0\": { obj0 },\n   *   \"1\": { obj1 },\n   *   \"3\": { obj3 }\n   * }\n   * ```\n   *\n   * Given back by the JS client:\n   *\n   * ```js\n   * [{ obj0 }, { obj1 }, null, { obj3 }]\n   * ```\n   *\n   * What we need:\n   *\n   * ```js\n   * [ { id: '0', ...obj0 }, { id: '1', ...obj1 }, { id: '3', ...obj3 } ]\n   * ```\n   *\n   * https://www.firebase.com/docs/web/guide/understanding-data.html#section-arrays-in-firebase\n   *\n   * @param {Array} arr   Input array\n   * @return {Array}      Fixed array\n   * @private\n   */\n  _addNumericIdsToEmbeddedArray(arr) {\n    var result = [];\n    for (var i = 0; i <  arr.length; i++) {\n      if (arr[i]) {\n        if (typeof arr[i] !== 'object') {\n          throw new Error(`expecting embedded object hash but found ${JSON.stringify(arr[i])}`);\n        }\n        result.push(assign({ id: '' + i }, arr[i]));\n      }\n    }\n    return result;\n  },\n\n\n  /**\n   * Even when records are embedded, bypass EmbeddedRecordsMixin\n   * and invoke JSONSerializer's method which serializes to ids only.\n   *\n   * The adapter handles saving the embedded records via `r.save()`\n   * and ensures that dirty states and rollback work.\n   *\n   * Will not be neccesary when this issue is resolved:\n   *\n   * https://github.com/emberjs/data/issues/2487\n   *\n   * @override\n   */\n  serializeHasMany(snapshot, json, relationship) {\n    DS.JSONSerializer.prototype.serializeHasMany.call(this, snapshot, json, relationship);\n  },\n\n\n  /**\n   * @see #serializeHasMany\n   * @override\n   */\n  serializeBelongsTo(snapshot, json, relationship) {\n    DS.JSONSerializer.prototype.serializeBelongsTo.call(this, snapshot, json, relationship);\n  },\n\n\n  /**\n   * @override\n   */\n  _shouldSerializeHasMany(snapshot, key, relationship) {\n    return this._canSerialize(key);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/services/firebase-app.js":"import firebase from 'firebase';\nimport Ember from 'ember';\n\nconst { getOwner } = Ember;\n\nexport default {\n  create(application) {\n    const config = getOwner(application)._lookupFactory('config:environment');\n    if (!config || typeof config.firebase !== 'object') {\n      throw new Error('Please set the `firebase` property in your environment config.');\n    }\n\n    let app;\n\n    try {\n      app = firebase.app();\n    } catch (e) {\n      app = firebase.initializeApp(config.firebase);\n    }\n\n    return app;\n  },\n\n  config: null,\n  isServiceFactory: true\n};\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/services/firebase.js":"import firebase from 'firebase';\nimport Ember from 'ember';\n\nconst { getOwner } = Ember;\n\nexport default {\n  create(application) {\n    const config = getOwner(application)._lookupFactory('config:environment');\n    if (!config || typeof config.firebase !== 'object') {\n      throw new Error('Please set the `firebase` property in your environment config.');\n    }\n\n    let app;\n\n    try {\n      app = firebase.app();\n    } catch (e) {\n      app = firebase.initializeApp(config.firebase);\n    }\n\n    return app.database().ref();\n  },\n\n  config: null,\n  isServiceFactory: true\n};\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/torii-adapters/firebase.js":"import Ember from 'ember';\n\nexport default Ember.Object.extend({\n  firebaseApp: Ember.inject.service(),\n\n  /**\n   * Extacts session information from authentication response\n   *\n   * @param {!firebase.User} user\n   * @return {Promise}\n   */\n  open(user) {\n    return Ember.RSVP.resolve({\n      provider: this.extractProviderId_(user),\n      uid: user.uid,\n      currentUser: user\n    });\n  },\n\n\n  /**\n   * Restore existing authenticated session\n   *\n   * @return {Promise}\n   */\n  fetch() {\n    return this.fetchAuthState_()\n      .then((user) => {\n        if (!user) {\n          return this.fetchRedirectState_();\n        }\n        return user;\n      })\n      .then((user) => {\n        if (!user) {\n          return Ember.RSVP.reject(new Error('No session available'));\n        }\n        return this.open(user);\n      })\n      .catch((err) => Ember.RSVP.reject(err));\n  },\n\n\n  /**\n   * Fetches the redirect user, if any.\n   *\n   * @return {!Promise<?firebase.User>}\n   * @private\n   */\n  fetchRedirectState_() {\n    let auth = this.get('firebaseApp').auth();\n    return auth.getRedirectResult()\n      .then(result => result.user);\n  },\n\n\n  /**\n   * Promisifies the first value of onAuthStateChanged\n   *\n   * @return {!Promise<?firebase.User>}\n   * @private\n   */\n  fetchAuthState_() {\n    return new Ember.RSVP.Promise((resolve, reject) => {\n      let auth = this.get('firebaseApp').auth();\n      const unsub = auth.onAuthStateChanged((user) => {\n        unsub();\n        resolve(user);\n      },\n      (err) => {\n        unsub();\n        reject(err);\n      });\n    });\n  },\n\n\n  /**\n   * Close existing authenticated session\n   *\n   * @return {Promise}\n   */\n  close() {\n    return this.get('firebaseApp').auth().signOut();\n  },\n\n  /**\n   * Extracts the provider id from the firebase user\n   *\n   * @param {!firebase.User} user\n   * @private\n   */\n  extractProviderId_(user) {\n    if (user.isAnonymous) {\n      return 'anonymous';\n    }\n\n    if (user.providerData && user.providerData.length) {\n      return user.providerData[0].providerId;\n    }\n\n    return 'custom';\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/torii-providers/firebase.js":"import Ember from 'ember';\nimport Waitable from '../mixins/waitable';\n\nconst { getOwner } = Ember;\n\nexport default Ember.Object.extend(Waitable, {\n  firebaseApp: Ember.inject.service(),\n\n  open(options) {\n    var providerId = options.provider;\n    var reject = Ember.RSVP.reject;\n\n    if (!providerId) {\n      return reject(new Error('`provider` must be supplied'));\n    }\n\n    var auth = this.get('firebaseApp').auth();\n\n    switch (providerId) {\n      case 'password':\n        if (!options.email || !options.password) {\n          return this.waitFor_(reject(new Error('`email` and `password` must be supplied')));\n        }\n\n        return this.waitFor_(auth.signInWithEmailAndPassword(options.email, options.password));\n\n      case 'custom':\n        if (!options.token) {\n          return this.waitFor_(reject(new Error('A token must be supplied')));\n        }\n\n        return this.waitFor_(auth.signInWithCustomToken(options.token));\n\n      case 'anonymous':\n        return this.waitFor_(auth.signInAnonymously());\n\n      // oauth providers e.g. 'twitter'\n      default:\n        const ProviderClass = getOwner(this).lookup(`firebase-auth-provider:${providerId}`);\n        if (!ProviderClass) {\n          return this.waitFor_(reject(new Error('Unknown provider')));\n        }\n\n        const provider = new ProviderClass();\n\n        if (options.settings && options.settings.scope) {\n          options.settings.scope.split(',').forEach((s) => provider.addScope(s));\n        }\n\n        if (options.redirect === true) {\n          // promise will never resolve unless there is an error (due to redirect)\n          return this.waitFor_(auth.signInWithRedirect(provider));\n        }\n        return this.waitFor_(auth.signInWithPopup(provider));\n    }\n  },\n\n\n  /**\n   * Wraps a promise in test waiters.\n   *\n   * @param {!Promise} promise\n   * @return {!Promise}\n   */\n  waitFor_(promise) {\n    this._incrementWaiters();\n    return promise.then((result) => {\n      this._decrementWaiters();\n      if (result.user) {\n        return result.user;\n      }\n      return result;\n    }).catch((err) => {\n      this._decrementWaiters();\n      return Ember.RSVP.reject(err);\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/addon/utils/to-promise.js":"import Ember from 'ember';\n\nexport default function(fn, context, _args, errorMsg) {\n  var args = _args || [];\n  return new Ember.RSVP.Promise(function(resolve, reject) {\n    var callback = function(error) {\n      if (error) {\n        if (errorMsg && typeof error === 'object') {\n          error.location = errorMsg;\n        }\n        Ember.run(null, reject, error);\n      } else {\n        Ember.run(null, resolve);\n      }\n    };\n    args.push(callback);\n    fn.apply(context, args);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/app/initializers/emberfire.js":"import EmberFireInitializer from 'emberfire/initializers/emberfire';\n\nexport default EmberFireInitializer;\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/app/services/firebase-app.js":"import firebaseApp from 'emberfire/services/firebase-app';\n\nexport default firebaseApp;\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/app/services/firebase.js":"import firebase from 'emberfire/services/firebase';\n\nexport default firebase;\n","/home/travis/build/npmtest/node-npmtest-emberfire/node_modules/emberfire/app/torii-providers/firebase.js":"import FirebaseProvider from 'emberfire/torii-providers/firebase';\n\nexport default FirebaseProvider;\n"}